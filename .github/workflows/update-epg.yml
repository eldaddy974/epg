name: Build Custom EPG from Your M3U (Google Drive)

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - ".github/workflows/update-epg.yml"
      - "README.md"

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install lxml requests unidecode gdown

      # ðŸ‘‰ If your Drive link ever changes, only update FILE_ID below.
      - name: Download playlist from Google Drive (robust)
        env:
          FILE_ID: 1ycrzgwIoDsf_Rc11V3jj1D47mF33RTID
        run: |
          set -euo pipefail
          gdown --id "$FILE_ID" --output playlist.m3u
          echo "Playlist bytes: $(wc -c < playlist.m3u || true)"
          echo "First 5 lines:"
          head -n 5 playlist.m3u || true

      - name: Write builder script
        run: |
          cat > build_epg.py <<'PY'
          import os, re, sys, gzip, io, traceback
          from lxml import etree
          import requests
          from unidecode import unidecode

          def norm(s: str) -> str:
            if not s: return ""
            s = unidecode(s).strip().lower()
            s = re.sub(r"\s+", " ", s)
            return s

          try:
            if not os.path.exists("playlist.m3u") or os.path.getsize("playlist.m3u") == 0:
              print("FATAL: playlist.m3u missing or empty")
              sys.exit(1)

            txt = open("playlist.m3u", "r", encoding="utf-8", errors="ignore").read()

            # Grab tvg-id and tvg-name (many lists use one or the other)
            tvg_ids = set(m.group(1).strip() for m in re.finditer(r'tvg-id="([^"]+)"', txt))
            names = set(m.group(1).strip() for m in re.finditer(r'tvg-name="([^"]+)"', txt))
            # Some lists put the name right after -1,
            # e.g. #EXTINF:-1 ... ,Channel Name
            names |= set(m.group(1).strip() for m in re.finditer(r"#EXTINF:[^\n]*?,\s*([^\r\n]+)", txt))

            tvg_ids = {i for i in tvg_ids if i}
            names_norm = {norm(n) for n in names if n}

            print(f"Playlist: {len(tvg_ids)} unique tvg-ids; {len(names)} names")

            # Where to fetch EPG from. We'll try a small, reliable set of country feeds.
            # (Fetching 100+ that donâ€™t exist = many 404s and slow runs.)
            cc_list = [
              "fr","gb","us","ca","de","es","it","pt","nl","be",
              "se","no","dk","fi","pl","cz","sk","hu","ro","gr",
              "tr","ie","ch","at","au","nz","ar","br","mx","co",
              "jp","kr","in","id","sg","th","ph","my","vn","za","eg"
            ]

            # Keep only countries that appear in group/title or name to reduce noise
            txt_low = txt.lower()
            maybe = set()
            for cc in cc_list:
              pat = re.compile(rf"\b{cc}\b")
              if pat.search(txt_low):
                maybe.add(cc)
            if not maybe:
              maybe = {"fr","gb","us"}  # default trio

            print("Will try feeds:", sorted(maybe))

            root = etree.Element("tv")
            channels_seen = set()
            progs = 0

            for cc in sorted(maybe):
              url = f"https://iptv-org.github.io/epg/guides/{cc}.xml"
              print("Fetch", cc, url, "...")
              try:
                r = requests.get(url, timeout=40)
                if r.status_code != 200:
                  print("SKIP", cc, r.status_code)
                  continue
                data = r.content
                # decompress if gz (some mirrors serve gz)
                if data[:2] == b"\x1f\x8b":
                  with gzip.GzipFile(fileobj=io.BytesIO(data)) as gz:
                    data = gz.read()

                doc = etree.fromstring(data)

                for ch in doc.findall("channel"):
                  cid = ch.get("id") or ""
                  name_el = ch.find("display-name")
                  cname = name_el.text if name_el is not None else ""
                  if tvg_ids and cid not in tvg_ids:
                    # allow name matching as fallback
                    if cname and norm(cname) not in names_norm:
                      continue
                  # copy channel
                  if cid not in channels_seen:
                    channels_seen.add(cid)
                    root.append(ch)

                for pr in doc.findall("programme"):
                  cid = pr.get("channel") or ""
                  ok = False
                  if cid in channels_seen:
                    ok = True
                  elif not tvg_ids:
                    ok = True
                  if ok:
                    root.append(pr)
                    progs += 1

                print(f"  OK: channels so far {len(channels_seen)}, programmes {progs}")

              except Exception as e:
                print("  ERROR", cc, e)

            out = etree.tostring(root, encoding="utf-8", xml_declaration=True)
            open("epg.xml", "wb").write(out)
            print(f"Done. channels written={len(channels_seen)}, programmes written={progs}")

          except Exception:
            traceback.print_exc()
            sys.exit(1)
          PY

      - name: Build epg.xml filtered to your channels
        run: |
          set -euo pipefail
          python build_epg.py

      - name: Commit epg.xml
        run: |
          if [ ! -s epg.xml ]; then
            echo "epg.xml missing or empty"; exit 1
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add epg.xml
          if git diff --cached --quiet; then
            echo "No changes to commit."
          else
            git commit -m "chore: update epg from Drive playlist"
            git push
          fi
