name: Build Custom EPG from Your M3U (Google Drive)

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - ".github/workflows/update-epg.yml"
      - "README.md"

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install lxml requests unidecode gdown

      - name: Download playlist from Google Drive (robust)
        env:
          FILE_ID: 1ycrzgwIoDsf_Rc11V3jj1D47mF33RTID
        run: |
          set -euo pipefail
          gdown --id "$FILE_ID" --output playlist.m3u
          echo "Playlist bytes: $(wc -c < playlist.m3u || true)"
          head -n 5 playlist.m3u || true

      - name: Write builder script
        run: |
          cat > build_epg.py <<'PY'
          import os, re, sys, gzip, io, traceback
          from lxml import etree
          import requests
          from unidecode import unidecode

          MIRRORS = [
            "https://cdn.jsdelivr.net/gh/iptv-org/epg@master/guides/{cc}.xml",
            "https://raw.githubusercontent.com/iptv-org/epg/master/guides/{cc}.xml",
            "https://iptv-org.github.io/epg/guides/{cc}.xml",
          ]

          def fetch_guide(cc: str) -> bytes | None:
            for tpl in MIRRORS:
              url = tpl.format(cc=cc)
              try:
                r = requests.get(url, timeout=60)
                if r.status_code == 200:
                  data = r.content
                  if data[:2] == b"\x1f\x8b":
                    import gzip, io
                    with gzip.GzipFile(fileobj=io.BytesIO(data)) as gz:
                      data = gz.read()
                  print(f"  OK {cc} via {url}")
                  return data
                else:
                  print(f"  SKIP {cc} {r.status_code} via {url}")
              except Exception as e:
                print(f"  ERR  {cc} via {url}: {e}")
            return None

          def norm(s: str) -> str:
            if not s: return ""
            s = unidecode(s).strip().lower()
            s = re.sub(r"\s+", " ", s)
            return s

          try:
            if not os.path.exists("playlist.m3u") or os.path.getsize("playlist.m3u") == 0:
              print("FATAL: playlist.m3u missing or empty"); sys.exit(1)

            txt = open("playlist.m3u","r",encoding="utf-8",errors="ignore").read()
            tvg_ids = set(m.group(1).strip() for m in re.finditer(r'tvg-id="([^"]+)"', txt))
            names = set(m.group(1).strip() for m in re.finditer(r'tvg-name="([^"]+)"', txt))
            names |= set(m.group(1).strip() for m in re.finditer(r"#EXTINF:[^\n]*?,\s*([^\r\n]+)", txt))
            names_norm = {norm(n) for n in names if n}
            tvg_ids = {i for i in tvg_ids if i}
            print(f"Playlist: {len(tvg_ids)} unique tvg-ids; {len(names)} names")

            cc_list = [
              "fr","gb","us","ca","de","es","it","pt","nl","be","se","no","dk","fi","pl","cz","sk","hu","ro","gr",
              "tr","ie","ch","at","au","nz","ar","br","mx","co","jp","kr","in","id","sg","th","ph","my","vn","za","eg"
            ]
            txt_low = txt.lower()
            maybe = {cc for cc in cc_list if re.search(rf"\\b{cc}\\b", txt_low)}
            if not maybe: maybe = {"fr","gb","us"}
            print("Will try feeds:", sorted(maybe))

            root = etree.Element("tv")
            channels_seen = set()
            progs = 0

            for cc in sorted(maybe):
              print("Fetch", cc)
              data = fetch_guide(cc)
              if not data:
                continue
              try:
                doc = etree.fromstring(data)
              except Exception as e:
                print("  parse error", cc, e)
                continue

              for ch in doc.findall("channel"):
                cid = ch.get("id") or ""
                cname = (ch.findtext("display-name") or "").strip()
                if tvg_ids and cid not in tvg_ids:
                  if cname and norm(cname) not in names_norm:
                    continue
                if cid not in channels_seen:
                  channels_seen.add(cid)
                  root.append(ch)

              for pr in doc.findall("programme"):
                cid = pr.get("channel") or ""
                if cid in channels_seen or not tvg_ids:
                  root.append(pr); progs += 1

              print(f"  Tally: channels {len(channels_seen)}, programmes {progs}")

            open("epg.xml","wb").write(
              etree.tostring(root, encoding="utf-8", xml_declaration=True)
            )
            print(f"Done. channels written={len(channels_seen)}, programmes written={progs}")

          except Exception:
            traceback.print_exc(); sys.exit(1)
          PY

      - name: Build epg.xml filtered to your channels
        run: |
          set -euo pipefail
          python build_epg.py

      - name: Commit epg.xml
        run: |
          if [ ! -s epg.xml ]; then
            echo "epg.xml missing or empty"; exit 1
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add epg.xml
          if git diff --cached --quiet; then
            echo "No changes to commit."
          else
            git commit -m "chore: update epg from Drive playlist"
            git push
          fi
